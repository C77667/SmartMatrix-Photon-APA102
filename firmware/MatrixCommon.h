/*
 * SmartMatrix Library - Common Definitions
 *
 * Copyright (c) 2015 Louis Beaudoin (Pixelmatix)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef _MATRIX_COMMON_H_
#define _MATRIX_COMMON_H_

#include <stdint.h>

#ifdef ARDUINO_ARCH_AVR
#include "Arduino.h"
#endif

// struct definitions for rgb24 and rgb48 with assignment operators
// between them; adding rgb36 didn't seem to make sense because even when
// packed with bitfields, it would only save 1 byte over rgb48.
struct rgb24;
struct rgb48;

typedef struct rgb24 {
    rgb24() : rgb24(0,0,0) {}
    rgb24(uint8_t r, uint8_t g, uint8_t b) {
        red = r; green = g; blue = b;
    }
    rgb24& operator=(const rgb24& col);
    rgb24& operator=(const rgb48& col);

    uint8_t red;
    uint8_t green;
    uint8_t blue;
} rgb24;

typedef struct rgb48 {
    rgb48() : rgb48(0,0,0) {}
    rgb48(uint16_t r, uint16_t g, uint16_t b) {
        red = r; green = g; blue = b;
    }
    rgb48& operator=(const rgb24& col);

    uint16_t red;
    uint16_t green;
    uint16_t blue;
} rgb48;

// todo: why is this assignment operator needed?  Implicitly defined assignment operator causes crashes when drawing to last pixel of last buffer of background bitmap
inline rgb24& rgb24::operator=(const rgb24& col) {
    red = col.red;
    green = col.green;
    blue = col.blue;
    return *this;
}

inline rgb24& rgb24::operator=(const rgb48& col) {
    red = col.red >> 8;
    green = col.green >> 8;
    blue = col.blue >> 8;
    return *this;
}

inline rgb48& rgb48::operator=(const rgb24& col) {
    red = col.red << 8;
    green = col.green << 8;
    blue = col.blue << 8;
    return *this;
}

#define NAME2(fun,suffix) fun ## suffix
#define NAME1(fun,suffix) NAME2(fun,suffix)
#define RGB_TYPE(depth) NAME1(rgb,depth)

//#if COLOR_DEPTH_RGB > 24
#define Chan8ToColor( c ) ((c) << 8)
//#else
//#define Chan8ToColor( c ) (c)
//#endif


//#if COLOR_DEPTH_RGB > 24
#define color_chan_t uint16_t
//#else
//#define color_chan_t uint8_t
//#endif


// source - somewhere on the internet (arduino forum?)
static const uint8_t lightPowerMap8bit[256] = {
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
    7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11,
    11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 16, 16, 17,
    17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24,
    25, 25, 26, 26, 27, 28, 28, 29, 29, 30, 31, 31, 32, 32, 33, 34,
    34, 35, 36, 37, 37, 38, 39, 39, 40, 41, 42, 43, 43, 44, 45, 46,
    47, 47, 48, 49, 50, 51, 52, 53, 54, 54, 55, 56, 57, 58, 59, 60,
    61, 62, 63, 64, 65, 66, 67, 68, 70, 71, 72, 73, 74, 75, 76, 77,
    79, 80, 81, 82, 83, 85, 86, 87, 88, 90, 91, 92, 94, 95, 96, 98,
    99, 100, 102, 103, 105, 106, 108, 109, 110, 112, 113, 115, 116, 118, 120, 121,
    123, 124, 126, 128, 129, 131, 132, 134, 136, 138, 139, 141, 143, 145, 146, 148,
    150, 152, 154, 155, 157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179,
    181, 183, 185, 187, 189, 191, 193, 196, 198, 200, 202, 204, 207, 209, 211, 214,
    216, 218, 220, 223, 225, 228, 230, 232, 235, 237, 240, 242, 245, 247, 250, 252
};


// generated by adafruit utility included with matrix library
// options: planes = 16 and GAMMA = 2.5
// shifted everything over by one and added a 257th entry for Fadecandy Interpolation compatibility
static const uint16_t lightPowerMap16bit[] = {
    0x00 >> 1, 0x00 >> 1, 0x00 >> 1, 0x01 >> 1, 0x02 >> 1, 0x04 >> 1, 0x06 >> 1, 0x08 >> 1,
    0x0b >> 1, 0x0f >> 1, 0x14 >> 1, 0x19 >> 1, 0x1f >> 1, 0x26 >> 1, 0x2e >> 1, 0x37 >> 1,
    0x41 >> 1, 0x4b >> 1, 0x57 >> 1, 0x63 >> 1, 0x71 >> 1, 0x80 >> 1, 0x8f >> 1, 0xa0 >> 1,
    0xb2 >> 1, 0xc5 >> 1, 0xda >> 1, 0xef >> 1, 0x106 >> 1, 0x11e >> 1, 0x137 >> 1, 0x152 >> 1,
    0x16e >> 1, 0x18b >> 1, 0x1a9 >> 1, 0x1c9 >> 1, 0x1eb >> 1, 0x20e >> 1, 0x232 >> 1, 0x257 >> 1,
    0x27f >> 1, 0x2a7 >> 1, 0x2d2 >> 1, 0x2fd >> 1, 0x32b >> 1, 0x359 >> 1, 0x38a >> 1, 0x3bc >> 1,
    0x3ef >> 1, 0x425 >> 1, 0x45c >> 1, 0x494 >> 1, 0x4cf >> 1, 0x50b >> 1, 0x548 >> 1, 0x588 >> 1,
    0x5c9 >> 1, 0x60c >> 1, 0x651 >> 1, 0x698 >> 1, 0x6e0 >> 1, 0x72a >> 1, 0x776 >> 1, 0x7c4 >> 1,
    0x814 >> 1, 0x866 >> 1, 0x8b9 >> 1, 0x90f >> 1, 0x967 >> 1, 0x9c0 >> 1, 0xa1b >> 1, 0xa79 >> 1,
    0xad8 >> 1, 0xb3a >> 1, 0xb9d >> 1, 0xc03 >> 1, 0xc6a >> 1, 0xcd4 >> 1, 0xd3f >> 1, 0xdad >> 1,
    0xe1d >> 1, 0xe8f >> 1, 0xf03 >> 1, 0xf79 >> 1, 0xff2 >> 1, 0x106c >> 1, 0x10e9 >> 1, 0x1168 >> 1,
    0x11e9 >> 1, 0x126c >> 1, 0x12f2 >> 1, 0x137a >> 1, 0x1404 >> 1, 0x1490 >> 1, 0x151f >> 1, 0x15b0 >> 1,
    0x1643 >> 1, 0x16d9 >> 1, 0x1771 >> 1, 0x180b >> 1, 0x18a7 >> 1, 0x1946 >> 1, 0x19e8 >> 1, 0x1a8b >> 1,
    0x1b32 >> 1, 0x1bda >> 1, 0x1c85 >> 1, 0x1d33 >> 1, 0x1de2 >> 1, 0x1e95 >> 1, 0x1f49 >> 1, 0x2001 >> 1,
    0x20bb >> 1, 0x2177 >> 1, 0x2236 >> 1, 0x22f7 >> 1, 0x23bb >> 1, 0x2481 >> 1, 0x254a >> 1, 0x2616 >> 1,
    0x26e4 >> 1, 0x27b5 >> 1, 0x2888 >> 1, 0x295e >> 1, 0x2a36 >> 1, 0x2b11 >> 1, 0x2bef >> 1, 0x2cd0 >> 1,
    0x2db3 >> 1, 0x2e99 >> 1, 0x2f81 >> 1, 0x306d >> 1, 0x315a >> 1, 0x324b >> 1, 0x333f >> 1, 0x3435 >> 1,
    0x352e >> 1, 0x3629 >> 1, 0x3728 >> 1, 0x3829 >> 1, 0x392d >> 1, 0x3a33 >> 1, 0x3b3d >> 1, 0x3c49 >> 1,
    0x3d59 >> 1, 0x3e6b >> 1, 0x3f80 >> 1, 0x4097 >> 1, 0x41b2 >> 1, 0x42d0 >> 1, 0x43f0 >> 1, 0x4513 >> 1,
    0x463a >> 1, 0x4763 >> 1, 0x488f >> 1, 0x49be >> 1, 0x4af0 >> 1, 0x4c25 >> 1, 0x4d5d >> 1, 0x4e97 >> 1,
    0x4fd5 >> 1, 0x5116 >> 1, 0x525a >> 1, 0x53a1 >> 1, 0x54eb >> 1, 0x5638 >> 1, 0x5787 >> 1, 0x58da >> 1,
    0x5a31 >> 1, 0x5b8a >> 1, 0x5ce6 >> 1, 0x5e45 >> 1, 0x5fa7 >> 1, 0x610d >> 1, 0x6276 >> 1, 0x63e1 >> 1,
    0x6550 >> 1, 0x66c2 >> 1, 0x6837 >> 1, 0x69af >> 1, 0x6b2b >> 1, 0x6caa >> 1, 0x6e2b >> 1, 0x6fb0 >> 1,
    0x7139 >> 1, 0x72c4 >> 1, 0x7453 >> 1, 0x75e5 >> 1, 0x777a >> 1, 0x7912 >> 1, 0x7aae >> 1, 0x7c4c >> 1,
    0x7def >> 1, 0x7f94 >> 1, 0x813d >> 1, 0x82e9 >> 1, 0x8498 >> 1, 0x864b >> 1, 0x8801 >> 1, 0x89ba >> 1,
    0x8b76 >> 1, 0x8d36 >> 1, 0x8efa >> 1, 0x90c0 >> 1, 0x928a >> 1, 0x9458 >> 1, 0x9629 >> 1, 0x97fd >> 1,
    0x99d4 >> 1, 0x9bb0 >> 1, 0x9d8e >> 1, 0x9f70 >> 1, 0xa155 >> 1, 0xa33e >> 1, 0xa52a >> 1, 0xa71a >> 1,
    0xa90d >> 1, 0xab04 >> 1, 0xacfe >> 1, 0xaefb >> 1, 0xb0fc >> 1, 0xb301 >> 1, 0xb509 >> 1, 0xb715 >> 1,
    0xb924 >> 1, 0xbb37 >> 1, 0xbd4d >> 1, 0xbf67 >> 1, 0xc184 >> 1, 0xc3a5 >> 1, 0xc5ca >> 1, 0xc7f2 >> 1,
    0xca1e >> 1, 0xcc4d >> 1, 0xce80 >> 1, 0xd0b7 >> 1, 0xd2f1 >> 1, 0xd52f >> 1, 0xd771 >> 1, 0xd9b6 >> 1,
    0xdbfe >> 1, 0xde4b >> 1, 0xe09b >> 1, 0xe2ef >> 1, 0xe547 >> 1, 0xe7a2 >> 1, 0xea01 >> 1, 0xec63 >> 1,
    0xeeca >> 1, 0xf134 >> 1, 0xf3a2 >> 1, 0xf613 >> 1, 0xf888 >> 1, 0xfb02 >> 1, 0xfd7e >> 1, 0xffff >> 1,
    0xffff >> 1
};

// adafruit matrix library
static const uint8_t lightPowerMap4bit[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07,
    0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
    0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b,
    0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0c, 0x0c,
    0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d, 0x0d,
    0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0e,
    0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x0f, 0x0f
};

inline void calculateBackgroundLUT(color_chan_t * lut, uint8_t backgroundBrightness) {
    // update background table
    for(int i=0; i<257; i++) {
        lut[i] = (lightPowerMap16bit[i] * backgroundBrightness) / 256;
    }
}

// function from Fadecandy
static inline
uint32_t lutInterpolate(const uint16_t *lut, uint32_t arg)
{
    /*
     * Using our color LUT for the indicated channel, convert the
     * 16-bit intensity "arg" in our input colorspace to a corresponding
     * 16-bit intensity in the device colorspace.
     *
     * Remember that our LUT is 257 entries long. The final entry corresponds to an
     * input of 0x10000, which can't quite be reached.
     *
     * 'arg' is in the range [0, 0xFFFF]
     *
     * This operation is equivalent to the following:
     *
     *      unsigned index = arg >> 8;          // Range [0, 0xFF]
     *      unsigned alpha = arg & 0xFF;        // Range [0, 0xFF]
     *      unsigned invAlpha = 0x100 - alpha;  // Range [1, 0x100]
     *
     *      // Result in range [0, 0xFFFF]
     *      return (lut[index] * invAlpha + lut[index + 1] * alpha) >> 8;
     *
     * This is easy to understand, but it turns out to be a serious bottleneck
     * in terms of speed and memory bandwidth, as well as register pressure that
     * affects the compilation of updatePixel().
     *
     * To speed this up, we try and do the lut[index] and lut[index+1] portions
     * in parallel using the SMUAD instruction. This is a pair of 16x16 multiplies,
     * and the results are added together. We can combine this with an unaligned load
     * to grab two adjacent entries from the LUT. The remaining complications are:
     *
     *   1. We wanted unsigned, not signed
     *   2. We still need to generate the input values efficiently.
     *
     * (1) is easy to solve if we're okay with 15-bit precision for the LUT instead
     * of 16-bit, which is fine. During LUT preparation, we right-shift each entry
     * by 1, keeping them within the positive range of a signed 16-bit int.
     *
     * For (2), we need to quickly put 'alpha' in the high halfword and invAlpha in
     * the low halfword, or vice versa. One fast way to do this is (0x01000000 + x - (x << 16).
     */

    uint32_t index = arg >> 8;          // Range [0, 0xFF]

    unsigned alpha = arg & 0xFF;        // Range [0, 0xFF]

// optimized code for Cortex M4 using SMUADX instruction, won't work with all platforms
#if 0
    // Load lut[index] into low halfword, lut[index+1] into high halfword.
    uint32_t pair = *(const uint32_t*)(lut + index);

    // Reversed halfword order
    uint32_t pairAlpha = (0x01000000 + alpha - (alpha << 16));

    return __SMUADX(pairAlpha, pair) >> 7;
#else
    unsigned invAlpha = 0x100 - alpha;  // Range [1, 0x100]

    return (lut[index] * invAlpha + lut[index + 1] * alpha) >> 8;
#endif
}

template <typename RGB_IN>
void colorCorrection(const RGB_IN& in, rgb48& out) {
    out = rgb48(lightPowerMap16bit[in.red] << 1,
                lightPowerMap16bit[in.green] << 1,
                lightPowerMap16bit[in.blue] << 1);
}

template <typename RGB_IN>
void colorCorrection(const RGB_IN& in, rgb24& out) {
    out = rgb24(lightPowerMap16bit[in.red] << 1,
                lightPowerMap16bit[in.green] << 1,
                lightPowerMap16bit[in.blue] << 1);
}

// config
typedef enum rotationDegrees {
    rotation0,
    rotation90,
    rotation180,
    rotation270
} rotationDegrees;

#endif
